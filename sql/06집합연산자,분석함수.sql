--집합연산자
SELECT * FROM EMPLOYEES;
--UNION = 합집합(중복X)
--컬럼개수가 일치해야 집합연산자 사용이 가능합니다.
SELECT FIRST_NAME, HIRE_DATE FROM EMPLOYEES WHERE HIRE_DATE LIKE '04%'
UNION
SELECT FIRST_NAME, HIRE_DATE FROM EMPLOYEES WHERE DEPARTMENT_ID = 20;

--UNION ALL = 합집합(중복O)
SELECT FIRST_NAME, HIRE_DATE FROM EMPLOYEES WHERE HIRE_DATE LIKE '04%'
UNION ALL
SELECT FIRST_NAME, HIRE_DATE FROM EMPLOYEES WHERE DEPARTMENT_ID = 20;


--INTERSECT = 교집합
SELECT FIRST_NAME, HIRE_DATE FROM EMPLOYEES WHERE HIRE_DATE LIKE '04%'
INTERSECT
SELECT FIRST_NAME, HIRE_DATE FROM EMPLOYEES WHERE DEPARTMENT_ID = 20;

--MINUS = 차집합
SELECT FIRST_NAME, HIRE_DATE FROM EMPLOYEES WHERE HIRE_DATE LIKE '04%'
MINUS
SELECT FIRST_NAME, HIRE_DATE FROM EMPLOYEES WHERE DEPARTMENT_ID = 20;

--UNION ALL은 가상테이블을 만들때 사용이 가능합니다.
SELECT EMPLOYEE_ID, FIRST_NAME FROM EMPLOYEES
UNION ALL
SELECT 200, 'HONGKILDONG' FROM DUAL
UNION ALL
SELECT 300, 'LEE' FROM DUAL
UNION ALL
SELECT 400, 'PARK' FROM DUAL;

----------------------------------------------------------------------------------
-- 분석함수

-- 시험의 단골문제
-- 분석함수는 OVER(조건)과 반드시 함께 사용됩니다.
SELECT EMPLOYEE_ID, FIRST_NAME, SALARY, 
RANK() OVER(ORDER BY SALARY DESC) AS "중복등수",
DENSE_RANK() OVER(ORDER BY SALARY DESC) AS "중복없는등수",
ROW_NUMBER() OVER(ORDER BY SALARY ASC) AS "일련번호"
FROM EMPLOYEES;

-- ROWNUM과의 차이 - ROWNUM은 ORDER BY 시에 결과가 바뀝니다
SELECT ROWNUM, EMPLOYEE_ID, FIRST_NAME, SALARY FROM EMPLOYEES
ORDER BY SALARY;




