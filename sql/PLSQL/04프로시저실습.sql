--1. 프로시저명 GUGUPROC
--- 구구단 을 입력받아 해당 단수를 출력하는 procedure을 생성하고 실행하세요

CREATE OR REPLACE PROCEDURE GUGUPROC (
    DAN IN NUMBER
)
IS
BEGIN
    FOR I IN 1..9
    LOOP
    DBMS_OUTPUT.put_line(DAN ||' X ' || I || ' = ' || DAN*I);
    END LOOP;

END;
EXEC guguproc(3);


--2. 프로시저명 EMP_YEAR_PROC
--- EMPLOYEE_ID를 받아서 EMPLOYEES에 존재하면, "근속년수를 출력" 하고, 없다면 "EMPLOYEE_ID는 없습니다" 를 출력하는 프로시저
--- 예외처리도 작성해주세요.
SELECT HIRE_DATE FROM EMPLOYEES;
CREATE OR REPLACE PROCEDURE EMP_YEAR_PROC(
    P_EMPLOYEE_ID IN EMPLOYEES.EMPLOYEE_ID%TYPE
)
IS
    CNT NUMBER := 0;
    EMP_HIRE_YEAR NUMBER;
BEGIN
    SELECT COUNT(*) INTO CNT
    FROM EMPLOYEES WHERE EMPLOYEE_ID = P_EMPLOYEE_ID;
    
    IF CNT = 0 THEN 
        DBMS_OUTPUT.put_line('EMPLOYEE_ID는 없습니다');
    ELSE
        SELECT TRUNC((SYSDATE - HIRE_DATE) /365) INTO EMP_HIRE_YEAR
        FROM EMPLOYEES WHERE EMPLOYEE_ID = P_EMPLOYEE_ID;
        DBMS_OUTPUT.put_line('근속년수 : ' ||EMP_HIRE_YEAR);
    END IF;
    
    EXCEPTION WHEN OTHERS THEN
        DBMS_OUTPUT.PUT_LINE('예외가 발생했습니다');
END;

EXEC EMP_YEAR_PROC(100);

--3. 프로시저명 DEPTS_PROC
--- 부서번호, 부서명, 작업 flag(I: insert, U:update, D:delete)을 매개변수로 받아 
--DEPTS테이블에 각각 flag가 i면 INSERT, u면 UPDATE, d면 DELETE 하는 프로시저를 생성합니다.
--- 그리고 정상종료라면 commit, 예외라면 롤백 처리하도록 처리하세요.
--- 예외처리도 작성해주세요.
SELECT * FROM DEPTS;
DROP TABLE DEPTS;
CREATE TABLE DEPTS AS (SELECT * FROM DEPARTMENTS WHERE 1 = 1);


DESC DEPTS;
CREATE OR REPLACE PROCEDURE DEPTS_PROC(
    P_DEPT_NUM IN DEPTS.DEPT_NO%TYPE,
    P_DEPT_NAME IN DEPTS.DEPT_NAME%TYPE,
    FLAG IN VARCHAR2
)
IS
BEGIN
    IF FLAG = 'I' THEN
        INSERT INTO DEPTS(DEPARTMENT_ID, DEPARTMENT_NAME) VALUES (P_DEPT_NUM, P_DEPT_NAME, SYSDATE);
    ELSIF FLAG = 'U' THEN
        UPDATE DEPTS SET DEPT_NAME = P_DEPT_NAME
        WHERE DEPT_NO = P_DEPT_NUM;
    ELSIF FLAG = 'D' THEN
        DELETE FROM DEPTS WHERE DEPT_NO = P_DEPT_NUM; 
    END IF;
    
    COMMIT;
    
    EXCEPTION WHEN OTHERS THEN
        DBMS_OUTPUT.PUT_LINE('예외가 발생했습니다');
        ROLLBACK;
END;

EXEC DEPTS_PROC(50, 'TEST' , 'I');

SELECT * FROM DEPTS;

--4. 프로시저명 EMP_AGE_PROC
--- employee_id를 입력받아 employees에 존재하면, 근속년수를 out하는 프로시저를 작성하세요.
--- 예외처리도 작성해주세요.

SELECT HIRE_DATE FROM EMPLOYEES;

CREATE OR REPLACE PROCEDURE EMP_AGE_PROC(
    P_EMPLOYEE_ID IN EMPLOYEES.EMPLOYEE_ID%TYPE,
    P_HIRE_YEAR OUT NUMBER
)
IS
    CNT NUMBER := 0;
BEGIN
    SELECT COUNT(*) INTO CNT
    FROM EMPLOYEES WHERE EMPLOYEE_ID = P_EMPLOYEE_ID;
    
    IF CNT = 0 THEN 
        DBMS_OUTPUT.put_line('EMPLOYEE_ID는 없습니다');
    ELSE
        SELECT TRUNC((SYSDATE-HIRE_DATE)/365) INTO P_HIRE_YEAR 
        FROM EMPLOYEES WHERE EMPLOYEE_ID = P_EMPLOYEE_ID;
    END IF;
    
    EXCEPTION WHEN OTHERS THEN
        DBMS_OUTPUT.PUT_LINE('예외가 발생했습니다');
END;

DECLARE
    HIRE_DATE_RESULT NUMBER;
BEGIN
    EMP_AGE_PROC(100, HIRE_DATE_RESULT);
    DBMS_OUTPUT.PUT_LINE('OUT HIRE_DATE_RESULT : ' || HIRE_DATE_RESULT);
END;


--5. 프로시저명 - EMP_MERGE_PROC
--- employees 테이블의 복사 테이블 emps를 생성합니다.
--- employee_id, last_name, email, hire_date, job_id를 입력받아 존재하면 이름, 이메일, 입사일, 직업을 update, 
--없다면 insert하는 merge문을 작성하세요
--- 힌트 (MERGE INTO 테이블 USING 조건 WHEN MATCHED THEN 업데이트 WHEN NOT MATCHED THEN 인서트 )

DROP TABLE EMPS;

CREATE TABLE EMPS AS (SELECT * FROM EMPLOYEES);
SELECT * FROM EMPS;

--MERGE INTO EMPS E1 USING(SELECT * FROM EMPLOYEES) E2 ON(E1.EMPLOYEE_ID = E2.EMPLOYEE_ID);

CREATE OR REPLACE PROCEDURE EMP_MERGE_PROC(
    P_EMPLOYEE_ID EMPS.employee_id%TYPE,
    P_LAST_NAME EMPS.last_name%TYPE,
    P_EMAIL EMPS.email%TYPE,
    P_HIRE_DATE EMPS.HIRE_DATE%TYPE,
    P_JOB_ID EMPS.job_id%TYPE
)
IS
BEGIN
        MERGE INTO EMPS A USING DUAL ON (A.EMPLOYEE_ID = P_EMPLOYEE_ID)
        WHEN MATCHED THEN
        UPDATE SET
        LAST_NAME = P_LAST_NAME, EMAIL = P_EMAIL,
        HIRE_DATE = P_HIRE_DATE, JOB_ID = P_JOB_ID 
        
        WHEN NOT MATCHED THEN
        INSERT (EMPLOYEE_ID, LAST_NAME, EMAIL, HIRE_DATE, JOB_ID) 
        VALUES (P_EMPLOYEE_ID, P_LAST_NAME, P_EMAIL, P_HIRE_DATE, P_JOB_ID);
END;

EXEC EMP_MERGE_PROC(200, 'TEST', 'TEST', SYSDATE, 'TEST');
EXEC EMP_MERGE_PROC(600, 'TEST', 'TEST', SYSDATE, 'TEST');
SELECT * FROM EMPS;

--6. 프로시저명 - SALES_PROC
--- sales테이블은 오늘의 판매내역이다.
--- day_of_sales테이블은 판매내역 마감시 오늘 일자의 총매출을 기록하는 테이블이다.
--- 마감시 sales의 오늘날짜 판매내역을 집계하여 day_of_sales에 집계하는 프로시저를 생성해보세요.
--조건) day_of_sales의 마감내역이 이미 존재하면 업데이트 처리

SELECT * FROM SALES;
DROP TABLE SALES;
CREATE TABLE SALES(
    SALE_NUM NUMBER(5) PRIMARY KEY,
    SALE_NAME VARCHAR2(30),
    SALE_PRICE NUMBER(10) NOT NULL,
    SALE_COUNT NUMBER(5),
    SALE_DATE DATE DEFAULT SYSDATE
);

INSERT INTO SALES VALUES (1, '사과', 5000, 5, SYSDATE);
INSERT INTO SALES VALUES (2, '바나나', 3000, 3, SYSDATE);
INSERT INTO SALES VALUES (3, '딸기', 10000, 1, SYSDATE);

CREATE TABLE DAY_OF_SALES(
    SALE_DATE DATE PRIMARY KEY,
    SALE_TOTLE_SALES NUMBER(10)
);
DROP TABLE DAY_OF_SALES;

CREATE OR REPLACE PROCEDURE SALES_PROC(
    P_TODAY_DATE DATE
)
IS
    P_TOTAL_SALES DAY_OF_SALES.SALE_TOTLE_SALES%TYPE;
    V_CNT NUMBER := 0;
BEGIN
    SELECT COUNT(*) 
    INTO V_CNT
    FROM DAY_OF_SALES 
    WHERE TO_CHAR(SALE_DATE, 'YYYY-MM-DD') = TO_CHAR(P_TODAY_DATE, 'YYYY-MM-DD');
    
    SELECT SUM(SALE_PRICE * SALE_COUNT)
    INTO P_TOTAL_SALES
    FROM SALES
    WHERE TO_CHAR(SALE_DATE, 'YYYY-MM-DD') = TO_CHAR(P_TODAY_DATE, 'YYYY-MM-DD');
        
    IF V_CNT = 0 THEN
        INSERT INTO DAY_OF_SALES VALUES (P_TODAY_DATE, P_TOTAL_SALES);
    ELSE
        UPDATE DAY_OF_SALES SET SALE_TOTLE_SALES = P_TOTAL_SALES;
    END IF;
END;

EXEC SALES_PROC(SYSDATE);

SELECT * FROM DAY_OF_SALES;
