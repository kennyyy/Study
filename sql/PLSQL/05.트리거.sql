--트리거 : 트리거는 테이블에 부착된 형태로 AFTER, BEFORE 트리거가 있습니다.

--AFTER - DML문장이 타켓테이블이 실행된 이후에 동작하는 트리거
--BEFORE - DML문장이 타겟테이블에 실행되기 이전에 동작하는 트리거
SET SERVEROUTPUT ON;
CREATE TABLE TBL_TEST(
    ID VARCHAR2(30),
    TEXT VARCHAR2(30)
);

CREATE OR REPLACE TRIGGER TBL_TEST_TRG
    AFTER INSERT OR UPDATE OR DELETE -- 트리거 종류
    ON TBL_TEST -- 부착할 테이블
    FOR EACH ROW -- 각행에 적용함
DECLARE
BEGIN
    DBMS_OUTPUT.put_line('트리거가 동작됨');
END;

SELECT * FROM TBL_TEST;

INSERT INTO TBL_TEST VALUES('1', '홍길동');
INSERT INTO TBL_TEST VALUES('2', '길동');
UPDATE TBL_TEST SET TEXT = 'TEST' WHERE ID = '1';
DELETE FROM TBL_TEST WHERE ID = '1';

--:OLD = 참조 전 열의 값 (INSERT : 입력 전 자료, UPDATE : 수정 전 자료, DELETE : 삭제할 자료)
--:NEW = 참조 후 열의 값 (INSERT : 입력 할 자료, UPDATE : 수정 된 자료)

CREATE TABLE TBL_USER(
    ID VARCHAR2(30) PRIMARY KEY,
    NAME VARCHAR2(30),
    ADDRESS VARCHAR2(30)
);

CREATE TABLE TBL_USER_BACKUP(
    ID VARCHAR2(20),
    NAME VARCHAR2(20),
    ADDRESS VARCHAR2(30),
    UPDATEDATE DATE DEFAULT SYSDATE,--언제 수정되었나
    M_TYPE CHAR(10), -- 어떤 형태의 변경타입
    M_USER VARCHAR2(20) --누가 변경한지 사용자
);

--업데이트 OR 삭제가 일어날때 기존 데이터를 BACKUP에 저장한다.
CREATE OR REPLACE TRIGGER TRG_USER_BACKUP
    AFTER UPDATE OR DELETE
    ON TBL_USER
    FOR EACH ROW
DECLARE
    V_TYPE VARCHAR2(10);
BEGIN
    IF UPDATING THEN -- UPDATE가 일어나면 TRUE를 반환하는 TRIGGER에서 사용한 구문
        V_TYPE := 'UPDATE';
    ELSIF DELETING THEN
        V_TYPE := 'DELETE';
    END IF;
    
    INSERT INTO TBL_USER_BACKUP VALUES( :OLD.ID, :OLD.NAME, :OLD.ADDRESS, SYSDATE, V_TYPE, USER());
    
END;


INSERT INTO TBL_USER VALUES('TEST01', 'ADMIN', '서울'); --트리거 아직 동작 X INSERT 설정안해줘서 그럼
INSERT INTO TBL_USER VALUES('TEST02', 'ADMIN', '경기');
INSERT INTO TBL_USER VALUES('TEST03', 'ADMIN', '부산');

UPDATE TBL_USER SET ADDRESS = '부산' WHERE ID = 'TEST01'; --트리거동작
UPDATE TBL_USER SET ADDRESS = 'YYY' WHERE ID = 'TEST01'; --트리거동작
DELETE FROM TBL_USER WHERE ID = 'TEST02'; --트리거동작

SELECT * FROM TBL_USER_BACKUP;

-----------------------------------------------------------------
SELECT * FROM TBL_USER;

CREATE OR REPLACE TRIGGER TRG_USER_MASKING_TRG
    BEFORE INSERT -- INSERT이전에 동작
    ON TBL_USER
    FOR EACH ROW
DECLARE
   
BEGIN
    :NEW.NAME := SUBSTR( :NEW.NAME, 1, 1) || '****';
END;
INSERT INTO TBL_USER VALUES('TEST05', 'ADMIN', '인천');


---------------------------------------------------------------

--1. 주문이 들어와서 주문테이블에 데이터가 INSERT되면 자동으로 상품테이블의 수량이 감소되는 트리거를 생성해보세요.

--주문(주문은 한번에 한 상품밖에 못한다고 가정)
CREATE TABLE ORDER_HISTORY (
    HISTORY_NO NUMBER(5) PRIMARY KEY,
    PRODUCT_NO NUMBER(5), --FK
    TOTAL NUMBER(10), --수량
    PRICE NUMBER(10) --금액
);
--상품
CREATE TABLE PRODUCT (
    PRODUCT_NO NUMBER(5) PRIMARY KEY,
    PRODUCT_NAME VARCHAR(20),
    TOTAL NUMBER(5),
    PRICE NUMBER(5)
);

CREATE OR REPLACE TRIGGER COUNT_DOWN_TRG
    AFTER INSERT
    ON ORDER_HISTORY
    FOR EACH ROW
DECLARE
    P_TOTAL NUMBER := :NEW.TOTAL;
    P_NO NUMBER := :NEW.PRODUCT_NO;
BEGIN
    UPDATE PRODUCT SET TOTAL = TOTAL - P_TOTAL 
    WHERE PRODUCT_NO = P_NO;
END;

DROP TRIGGER COUNT_DOWN_TRG;

INSERT INTO PRODUCT VALUES(1, '피자', 100, 10000); 
INSERT INTO PRODUCT VALUES(2, '치킨', 100, 15000); 
INSERT INTO PRODUCT VALUES(3, '햄버거', 100, 5000);

INSERT INTO ORDER_HISTORY VALUES(3, 3, 10, 5000 * 10);

SELECT * FROM PRODUCT;

SELECT * FROM ORDER_HISTORY;

